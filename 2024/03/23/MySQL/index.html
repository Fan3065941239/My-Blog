<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>MySQL深入浅出 | FANSEA</title><meta name="keywords" content="mysql"><meta name="author" content="FANSEA"><meta name="copyright" content="FANSEA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="MySQL深入浅出"><meta name="application-name" content="MySQL深入浅出"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="MySQL深入浅出"><meta property="og:url" content="http://example.com/2024/03/23/MySQL/index.html"><meta property="og:site_name" content="FANSEA"><meta property="og:description" content="MySQL深入浅出开篇第一问一个场景题：一个Mysql单表，列是 （唯一id，订单类型，订单时间，金额），一天有三千万条数据，现在要将昨天的数据打印出来，怎么设计索引？具体怎么操作？然后现在要根据订单类型计算每种订单类型的金额总和，怎么操作？ 提示：根据时间分，提交多线程；随后追问怎么计算金额总和"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/fansea.png"><meta property="article:author" content="FANSEA"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/fansea.png"><meta name="description" content="MySQL深入浅出开篇第一问一个场景题：一个Mysql单表，列是 （唯一id，订单类型，订单时间，金额），一天有三千万条数据，现在要将昨天的数据打印出来，怎么设计索引？具体怎么操作？然后现在要根据订单类型计算每种订单类型的金额总和，怎么操作？ 提示：根据时间分，提交多线程；随后追问怎么计算金额总和"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/03/23/MySQL/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: FANSEA","link":"链接: ","source":"来源: FANSEA","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'FANSEA',
  title: 'MySQL深入浅出',
  postAI: '',
  pageFillDescription: 'MySQL深入浅出, 开篇第一问, 设计索引, 打印昨天的数据, 根据订单类型计算金额总和, 使用多线程, 追问：怎么计算金额总和, 应用层实现, 索引查询 ❀, 创建索引, 使用索引进行查询, 注意事项, 联合索引, MySQL 执行流程是怎样的？, 第一步：连接器, 第二步：查询缓存, 第三步：解析 SQL, 第四步：执行 SQL, 预处理器, 优化器, 执行器, 主键索引查询, 全表扫描, 索引下推, 总结, SQL知识加油站, 关联查询 - inner join, 关联查询 - cross join, 关联查询 - outer join深入浅出开篇第一问一个场景题一个单表列是唯一订单类型订单时间金额一天有三千万条数据现在要将昨天的数据打印出来怎么设计索引具体怎么操作然后现在要根据订单类型计算每种订单类型的金额总和怎么操作提示根据时间分提交多线程随后追问怎么计算金额总和对于给定的场景我们需要设计一个有效的索引策略以便能够快速检索昨天的数据并且还要计算每种订单类型的金额总和设计索引考虑到查询需求主要是基于订单时间假设为字段和订单类型假设为字段我们可以设计一个复合索引来优化查询这个索引首先按照排序对于相同的时间再按照排序这样设计有几个好处范围查询优化当我们需要查询某个时间段内的数据时例如昨天的数据数据库可以利用索引快速定位到这个时间范围覆盖索引如果查询只需要和字段那么可以直接使用索引来满足查询而无需回表查找排序优化如果查询需要对结果进行排序并且排序顺序与索引顺序一致那么排序操作将非常高效打印昨天的数据要打印昨天的数据我们可以使用以下语句函数返回当前日期不包含时间部分从当前日期中减去一天得到昨天的日期这里使用了语句来指定时间范围从昨天的午夜开始到今天的午夜前一秒结束确保字段是日期时间类型如或以便能够正确地进行比较根据订单类型计算金额总和要计算每种订单类型的金额总和我们可以使用语句和聚合函数这个查询会返回每种订单类型及其对应的金额总和注意这里我们同样使用了之前定义的时间范围来限制结果集只包含昨天的数据使用多线程如果数据量非常大并且服务器有足够的资源可以考虑使用多线程来并行处理数据然而对于查询来说通常不需要显式地创建多线程来处理因为服务器内部已经为查询优化和执行做了大量的工作如果确实需要利用多线程来提高性能那么应该考虑在应用层实现比如将时间范围划分成多个子区间每个线程处理一个子区间的数据追问怎么计算金额总和在上面的语句中我们已经展示了如何计算金额总和通过我们可以得到每种订单类型的总金额这个操作是在查询中直接完成的会扫描符合条件的行并对每一行的字段进行求和然后按照进行分组如果数据量非常大计算过程可能会比较慢这时可以考虑以下几个优化策略确保索引有效如上所述确保和字段上有合适的索引以加速数据的检索和分组硬件和配置优化根据服务器的硬件配置如内存磁盘等调整的配置参数以优化查询性能分区表如果表非常大并且经常需要按时间范围查询数据可以考虑使用的分区表功能通过将表按照时间范围进行分区可以提高查询性能定期汇总如果订单数据的变更不频繁可以考虑定期如每天或每小时计算并存储订单类型的金额总和这样就不需要实时计算而是直接查询预先计算好的结果记住在实际应用中最佳的做法通常取决于具体的数据量查询频率硬件资源以及业务需求因此在实施任何优化策略之前最好先进行性能测试和分析以确定最有效的方案应用层实现在应用层使用多线程优化数据检索和计算操作通常涉及将任务划分为多个子任务并并行执行这些子任务以加快整体处理速度对于数据库查询和计算订单类型金额总和的场景可以通过以下步骤实现多线程优化任务分解首先确定哪些部分的任务可以并行执行在数据库查询的场景中如果查询的数据量非常大并且数据库服务器能够支持并发查询那么可以将查询拆分成多个子查询每个子查询负责检索一部分数据对于计算订单类型金额总和的任务如果每种订单类型的计算是独立的那么也可以将这些计算任务分配给不同的线程并行执行创建线程或线程池根据需要创建足够数量的线程或线程池来执行子任务使用线程池可以避免频繁地创建和销毁线程从而提高性能在中可以使用和来创建和管理线程池分配任务将子任务分配给线程池中的线程执行这通常涉及到将查询条件或计算参数传递给线程执行数据库查询如果查询任务被拆分成多个子查询每个线程将执行其分配的子查询并获取结果集确保数据库连接是线程安全的或者为每个线程创建独立的数据库连接计算金额总和对于计算订单类型金额总和的任务每个线程将处理其分配的订单类型并计算相应的金额总和可以使用线程安全的集合如来存储每个订单类型的计算结果以便后续合并合并结果当所有线程完成其任务后需要合并它们的结果对于数据库查询这通常意味着将各个子查询的结果集合并成一个完整的结果集对于金额总和的计算需要将各个线程计算的结果相加得到每种订单类型的总金额关闭线程池一旦所有任务完成并且结果已经合并关闭线程池以释放资源以下是一个简化的代码示例展示了如何使用线程池并行执行数据库查询任务假设有一个类用于执行数据库查询执行数据库查询并返回结果返回订单列表假设类代表订单包含订单类型和金额等字段其他字段和构造函数等创建一个固定大小的线程池假设我们按时间范围拆分查询任务昨天的开始时间昨天的结束时间或今天的开始时间假设我们将查询拆分成个任务好好学学别人如何多线程处理带返回值的任务等待所有任务完成并合并结果获取每个任务的结果并添加到总列表中方法关闭线程池现在可以对进行处理比如计算每种订单类型的金额总和等处理计算每种订单类型的金额总和如果订单类型已经存在于中则累加金额否则初始化金额为当前订单的金额这一步方法恰到好处查询是否存在键存在返回值不存在初始化值为打印每种订单类型的金额总和的遍历方法索引查询当你说根据自己创建索引查询我理解为你想了解如何根据自己的需求在数据库中创建索引并如何使用这些索引进行查询以下是一个简单的例子说明如何在关系型数据库中以为例创建索引并使用它进行查询创建索引假设我们有一个名为的表其中包含和三个字段如果我们经常根据字段进行查询那么为了提高查询效率我们可以为字段创建一个索引使用语句创建索引这条命令会在表的字段上创建一个名为的索引使用索引进行查询一旦索引创建成功你就可以在查询中使用它来提高性能例如如果你想根据字段查找用户你可以这样写查询优化器会自动决定是否使用索引来加速这个查询如果它认为使用索引比全表扫描更快它就会使用索引注意事项选择性索引的选择性越高其效果通常越好选择性是指不重复的索引值与总记录数的比率例如一个只有和两个值的字段可能不是一个好的索引候选因为它的选择性很低维护成本每次插入更新或删除记录时索引都需要被更新因此过多的索引会增加写操作的开销覆盖索引如果一个查询只需要访问索引中的信息而不需要回表访问数据行那么这个查询就被称为覆盖索引查询这种查询通常非常快避免过度索引只为那些经常出现在子句条件或子句中的列创建索引覆盖索引索引就是你需要查询的列话就不需要在磁盘加载其他数据块了直接在索引库找到数据返回减少次数效率非常高是指一个索引包含了查询所需的所有列而无需访问表的实际数据页当数据库系统执行查询时通常需要从磁盘中读取数据页到内存中才能进行处理而如果使用了覆盖索引由于索引已经包含了查询所需的所有列的值数据库系统可以直接通过索引来获取这些值而不需要额外地读取数据页这样可以减少磁盘的次数和数据在内存中的占用提高查询的效率最后为了确定你的索引是否有效地提高了查询性能你可以使用数据库的查询执行计划工具如的语句来查看查询是如何使用索引的联合索引当数据库表中同时建立索引和二级索引数据库索引库会发生什么变化当然是对字段生成一个索引库如果说叶子节点包含完整的用户记录索引库多了将会占用磁盘很大空间那我们该怎么办呢联想一下本身建立了索引并叶子节点携带所有数据查询是不是非常快那么是不思路豁然开朗了我们就可以选择重新建立索引库这次索引库叶子节点只包含和数据量大大降低根据所查到的再去索引库查询最终数据因为并不是一个主键索引所以可能会有多个对应结果这样就需要回表知道查询到对应的数据为止所以谈论这么多联合索引又是什么呢相当于同时创建的两个二级索引但是这个二级索引遵循最左原则同样的是根据两个索引加上主键索引创建索引库即叶子节点不携带数据这样的话会首先根据左边的索引先排序所以在叶子节点中会出现相同的节点这时才会根据排序所以说相同值的节点下可能会保存不同的所以如果直接搜索索引是乱序的就不会起作用执行流程是怎样的先来一个上帝视角图下面就是执行一条查询语句的流程也从图中可以看到内部架构里的各个功能模块可以看到的架构共分为两层层和存储引擎层层负责建立连接分析和执行大多数的核心功能模块都在这实现主要包括连接器查询缓存解析器预处理器优化器执行器等另外所有的内置函数如日期时间数学和加密函数等和所有跨存储引擎的功能如存储过程触发器视图等都在层实现存储引擎层负责数据的存储和提取支持等多个存储引擎不同的存储引擎共用一个层现在最常用的存储引擎是从版本开始成为了的默认存储引擎我们常说的索引数据结构就是由存储引擎层实现的不同的存储引擎支持的索引类型也不相同比如支持索引类型是树且是默认使用也就是说在数据表中创建的主键索引和二级索引默认使用的是树索引第一步连接器指定服务得地址如果是连接本地的服务可以不用这个参数指定用户名管理员角色名为指定密码如果命令行中不填写密码为了密码安全建议不要在命令行写密码就需要在交互对话里面输入密码查看连接最大连接时间查看当前连接列表支持最大连接数连接器的工作做完了简单总结一下与客户端进行三次握手建立连接校验客户端的用户名和密码如果用户名或密码不对则会报错如果用户名和密码都对了会读取该用户的权限然后后面的权限逻辑判断都基于此时读取到的权限第二步查询缓存查询缓存如果查到了直接返回但是事实上很鸡肋缓存在数据库表更新的时候会被删除以保证一致性所以查询命中概率不高所在在之后就抛弃了缓存这个概念连接器得工作完成后客户端就可以向服务发送语句了服务收到语句后就会解析出语句的第一个字段看看是什么类型的语句如果是查询语句语句就会先去查询缓存里查找缓存数据看看之前有没有执行过这一条命令这个查询缓存是以形式保存在内存中的为查询语句为语句查询的结果如果查询的语句命中查询缓存那么就会直接返回给客户端如果查询的语句没有命中查询缓存中那么就要往下继续执行等执行完后查询的结果就会被存入查询缓存中这么看查询缓存还挺有用但是其实查询缓存挺鸡肋的对于更新比较频繁的表查询缓存的命中率很低的因为只要一个表有更新操作那么这个表的查询缓存就会被清空如果刚缓存了一个查询结果很大的数据还没被使用的时候刚好这个表有更新操作查询缓冲就被清空了相当于缓存了个寂寞所以版本直接将查询缓存删掉了也就是说开始执行一条查询语句不会再走到查询缓存这个阶段了对于之前的版本如果想关闭查询缓存我们可以通过将参数设置成第三步解析解析器会做如下两件事情第一件事情词法分析会根据你输入的字符串识别出关键字出来例如语句在分析之后会得到个其中有个分别为和关键字非关键字关键字非关键字第二件事情语法分析根据词法分析的结果语法解析器会根据语法规则判断你输入的这个语句是否满足语法如果没问题就会构建出语法树这样方便后面模块获取类型表名字段名条件等等第四步执行经过解析器后接着就要进入执行查询语句的流程了每条查询语句流程主要可以分为下面这三个阶段阶段也就是预处理阶段阶段也就是优化阶段阶段也就是执行阶段预处理器查询表是否存在优化器小鱼同学优化器会在多种索引中使用效率最高的索引很显然这条查询语句是覆盖索引直接在二级索引就能查找到结果因为二级索引的树的叶子节点的数据存储的是主键值就没必要在主键索引查找了因为查询主键索引的树的成本会比查询二级索引的的成本大优化器基于查询成本的考虑会选择查询代价小的普通索引执行器作为存储引擎会调用方法来根据不同策略来搜素当搜索条件包含主键索引时方法逐步查询存储引擎通过主键索引的树结构定位到的第一条记录将数据返回给客户端当不包含索引时方法循环查询查询到匹配的将一个一个返回到客户端经历完优化器后就确定了执行方案接下来就真正开始执行语句了这个工作是由执行器完成的在执行的过程中执行器就会和存储引擎交互了交互是以记录为单位的执行器和存储引擎的交互过程主键索引查询全表扫描索引下推主键索引查询以本文开头查询语句为例看看执行器是怎么工作的这条查询语句的查询条件用到了主键索引而且是等值查询同时主键是唯一不会有相同的记录所以优化器决定选用访问类型为进行查询也就是使用主键索引查询一条记录那么执行器与存储引擎的执行流程是这样的执行器第一次查询会调用函数指针指向的函数因为优化器选择的访问类型为这个函数指针被指向为引擎索引查询的接口把条件交给存储引擎让存储引擎定位符合条件的第一条记录存储引擎通过主键索引的树结构定位到的第一条记录如果记录是不存在的就会向执行器上报记录找不到的错误然后查询结束如果记录是存在的就会将记录返回给执行器执行器从存储引擎读到记录后接着判断记录是否符合查询条件如果符合则发送给客户端如果不符合则跳过该记录执行器查询的过程是一个循环所以还会再查一次但是这次因为不是第一次查询了所以会调用函数指针指向的函数因为优化器选择的访问类型为这个函数指针被指向为一个永远返回的函数所以当调用该函数的时候执行器就退出循环也就是结束查询了至此这个语句就执行完成了全表扫描举个全表扫描的例子这条查询语句的查询条件没有用到索引所以优化器决定选用访问类型为进行查询也就是全表扫描的方式查询那么这时执行器与存储引擎的执行流程是这样的执行器第一次查询会调用函数指针指向的函数因为优化器选择的访问类型为这个函数指针被指向为引擎全扫描的接口让存储引擎读取表中的第一条记录执行器会判断读到的这条记录的是不是如果不是则跳过如果是则将记录发给客户的是的没错层每从存储引擎读到一条记录就会发送给客户端之所以客户端显示的时候是直接显示所有记录的是因为客户端是等查询语句查询完成后才会显示出所有的记录执行器查询的过程是一个循环所以还会再查一次会调用函数指针指向的函数因为优化器选择的访问类型为函数指针指向的还是引擎全扫描的接口所以接着向存储引擎层要求继续读刚才那条记录的下一条记录存储引擎把下一条记录取出后就将其返回给执行器层执行器继续判断条件不符合查询条件即跳过该记录否则发送到客户端一直重复上述过程直到存储引擎把表中的所有记录读完然后向执行器层返回了读取完毕的信息执行器收到存储引擎报告的查询完毕的信息退出循环停止查询索引下推在这部分非常适合讲索引下推推出的查询优化策略这样大家能清楚的知道下推这个动作下推到了哪里索引下推能够减少二级索引在查询时的回表操作提高查询的效率因为它将层部分负责的事情交给存储引擎层去处理了举一个具体的例子方便大家理解这里一张用户表如下我对和字段建立了联合索引现在有下面这条查询语句联合索引当遇到范围查询就会停止匹配也就是字段能用到联合索引但是字段则无法利用到索引具体原因这里可以看这篇索引常见面试题那么不使用索引下推之前的版本时执行器与存储引擎的执行流程是这样的层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录也就是定位到的第一条记录存储引擎根据二级索引的树快速定位到这条记录后获取主键值然后进行回表操作将完整的记录返回给层层在判断该记录的是否等于如果成立则将其发送给客户端否则跳过该记录接着继续向存储引擎索要下一条记录存储引擎在二级索引定位到记录后获取主键值然后回表操作将完整的记录返回给层如此往复直到存储引擎把表中的所有记录读完可以看到没有索引下推的时候每查询到一条二级索引记录都要进行回表操作然后将记录返回给接着再判断该记录的是否等于而使用索引下推后判断记录的是否等于的工作交给了存储引擎层过程如下层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录也就是定位到的第一条记录存储引擎定位到二级索引后先不执行回表操作而是先判断一下该索引中包含的列列的条件是否等于是否成立如果条件不成立则直接跳过该二级索引如果成立则执行回表操作将完成记录返回给层层在判断其他的查询条件本次查询没有其他条件是否成立如果成立则将其发送给客户端否则跳过该记录然后向存储引擎索要下一条记录如此往复直到存储引擎把表中的所有记录读完可以看到使用了索引下推后虽然列无法使用到联合索引但是因为它包含在联合索引里所以直接在存储引擎过滤出满足的记录后才去执行回表操作获取整个记录相比于没有使用索引下推节省了很多回表操作当你发现执行计划里的部分显示了说明使用了索引下推总结执行一条查询语句期间发生了什么连接器建立连接管理连接校验用户身份查询缓存查询语句如果命中查询缓存则直接返回否则继续往下执行已删除该模块解析通过解析器对查询语句进行词法分析语法分析然后构建语法树方便后续模块读取表名字段语句类型执行执行共有三个阶段预处理阶段检查表或字段是否存在将中的符号扩展为表上的所有列优化阶段基于查询成本的考虑选择查询成本最小的执行计划执行阶段根据执行计划执行查询语句从存储引擎读取记录返回给客户端知识加油站关联查询在中是一种常见的关联查询方式它根据两个表之间的关联条件将满足条件的行组合在一起注意只返回两个表中满足关联条件的交集部分即在两个表中都存在的匹配行关联查询在中关联查询是一种用于联合多个数据表中的数据的查询方式其中是一种简单的关联查询不需要任何条件来匹配行它直接将左表的每一行与右表的每一行进行组合返回的结果是两个表的笛卡尔积关联查询在中是一种关联查询方式它根据指定的关联条件将两个表中满足条件的行组合在一起并包含没有匹配的行在中包括和两种类型它们分别表示查询左表和右表的所有行即使没有被匹配再加上满足条件的交集部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-27 21:21:29',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">FANSEA</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>3</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/es/" style="font-size: 1.05rem;">es<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>1</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/%E4%BE%9D%E8%B5%96%E5%8C%85/" style="font-size: 1.05rem;">依赖包<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 1.05rem;">内网穿透<sup>1</sup></a><a href="/tags/%E5%95%86%E4%B8%9A%E6%80%9D%E8%80%83/" style="font-size: 1.05rem;">商业思考<sup>2</sup></a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">微服务<sup>1</sup></a><a href="/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/" style="font-size: 1.05rem;">技能提升<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E8%AE%B0/" style="font-size: 1.05rem;">日记<sup>1</sup></a><a href="/tags/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" style="font-size: 1.05rem;">登录校验<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>5</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">编程工具<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 1.05rem;">读书<sup>2</sup></a><a href="/tags/%E8%B1%AA%E8%BD%A6/" style="font-size: 1.05rem;">豪车<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>4</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>1</sup></a><a href="/tags/%EF%BC%9BMySQL/" style="font-size: 1.05rem;">；MySQL<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/mysql/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>mysql</span></a></span></div></div><h1 class="post-title" itemprop="name headline">MySQL深入浅出</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-03-23T07:42:06.000Z" title="发表于 2024-03-23 15:42:06">2024-03-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-03-27T13:21:29.039Z" title="更新于 2024-03-27 21:21:29">2024-03-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为湘潭"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>湘潭</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/03/23/MySQL/"><header><a href="/tags/mysql/" tabindex="-1" itemprop="url">mysql</a><h1 id="CrawlerTitle" itemprop="name headline">MySQL深入浅出</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">FANSEA</span><time itemprop="dateCreated datePublished" datetime="2024-03-23T07:42:06.000Z" title="发表于 2024-03-23 15:42:06">2024-03-23</time><time itemprop="dateCreated datePublished" datetime="2024-03-27T13:21:29.039Z" title="更新于 2024-03-27 21:21:29">2024-03-27</time></header><h1 id="MySQL深入浅出"><a href="#MySQL深入浅出" class="headerlink" title="MySQL深入浅出"></a>MySQL深入浅出</h1><h2 id="开篇第一问"><a href="#开篇第一问" class="headerlink" title="开篇第一问"></a>开篇第一问</h2><p>一个场景题：一个Mysql单表，列是 （唯一id，订单类型，订单时间，金额），一天有三千万条数据，现在要将昨天的数据打印出来，怎么设计索引？具体怎么操作？然后现在要根据订单类型计算每种订单类型的金额总和，怎么操作？</p>
<p>提示：根据时间分，提交多线程；随后追问怎么计算金额总和</p>
<p>对于给定的场景，我们需要设计一个有效的索引策略，以便能够快速检索昨天的数据，并且还要计算每种订单类型的金额总和。</p>
<h3 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h3><p>考虑到查询需求主要是基于订单时间（假设为<code>order_time</code>字段）和订单类型（假设为<code>order_type</code>字段），我们可以设计一个复合索引来优化查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_time_type <span class="keyword">ON</span> your_table_name(order_time, order_type);</span><br></pre></td></tr></table></figure>

<p>这个索引首先按照<code>order_time</code>排序，对于相同的时间，再按照<code>order_type</code>排序。这样设计有几个好处：</p>
<ol>
<li><strong>范围查询优化</strong>：当我们需要查询某个时间段内的数据时（例如昨天的数据），数据库可以利用索引快速定位到这个时间范围。</li>
<li><strong>覆盖索引</strong>：如果查询只需要<code>order_time</code>和<code>order_type</code>字段，那么MySQL可以直接使用索引来满足查询，而无需回表查找。</li>
<li><strong>排序优化</strong>：如果查询需要对结果进行排序，并且排序顺序与索引顺序一致，那么排序操作将非常高效。</li>
</ol>
<h3 id="打印昨天的数据"><a href="#打印昨天的数据" class="headerlink" title="打印昨天的数据"></a>打印昨天的数据</h3><p>要打印昨天的数据，我们可以使用以下SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">#CURDATE()函数返回当前日期（不包含时间部分）。</span><br><span class="line">#<span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>从当前日期中减去一天，得到昨天的日期。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> your_table_name</span><br><span class="line"><span class="keyword">WHERE</span> order_time <span class="keyword">BETWEEN</span> CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span> <span class="keyword">AND</span> CURDATE()</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>BETWEEN</code>语句来指定时间范围，从昨天的午夜开始到今天的午夜前一秒结束。确保<code>order_time</code>字段是日期时间类型（如<code>DATETIME</code>或<code>TIMESTAMP</code>），以便能够正确地进行比较。</p>
<h3 id="根据订单类型计算金额总和"><a href="#根据订单类型计算金额总和" class="headerlink" title="根据订单类型计算金额总和"></a>根据订单类型计算金额总和</h3><p>要计算每种订单类型的金额总和，我们可以使用<code>GROUP BY</code>语句和聚合函数<code>SUM</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_type, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> your_table_name</span><br><span class="line"><span class="keyword">WHERE</span> order_time <span class="keyword">BETWEEN</span> CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span> <span class="keyword">AND</span> CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_type;</span><br></pre></td></tr></table></figure>

<p>这个查询会返回每种订单类型及其对应的金额总和。注意，这里我们同样使用了之前定义的时间范围来限制结果集只包含昨天的数据。</p>
<h3 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h3><p>如果数据量非常大，并且服务器有足够的资源，可以考虑使用多线程来并行处理数据。然而，对于MySQL查询来说，通常不需要显式地创建多线程来处理，因为MySQL服务器内部已经为查询优化和执行做了大量的工作。如果确实需要利用多线程来提高性能，那么应该考虑在应用层实现，比如将时间范围划分成多个子区间，每个线程处理一个子区间的数据。</p>
<h3 id="追问：怎么计算金额总和"><a href="#追问：怎么计算金额总和" class="headerlink" title="追问：怎么计算金额总和"></a>追问：怎么计算金额总和</h3><p>在上面的SQL语句中，我们已经展示了如何计算金额总和。通过<code>SUM(amount)</code>，我们可以得到每种订单类型的总金额。这个操作是在SQL查询中直接完成的，MySQL会扫描符合条件的行，并对每一行的<code>amount</code>字段进行求和，然后按照<code>order_type</code>进行分组。</p>
<p>如果数据量非常大，计算过程可能会比较慢，这时可以考虑以下几个优化策略：</p>
<ol>
<li><strong>确保索引有效</strong>：如上所述，确保<code>order_time</code>和<code>order_type</code>字段上有合适的索引，以加速数据的检索和分组。</li>
<li><strong>硬件和配置优化</strong>：根据服务器的硬件配置（如CPU、内存、磁盘I&#x2F;O等）调整MySQL的配置参数，以优化查询性能。</li>
<li><strong>分区表</strong>：如果表非常大，并且经常需要按时间范围查询数据，可以考虑使用MySQL的分区表功能。通过将表按照时间范围进行分区，可以提高查询性能。</li>
<li><strong>定期汇总</strong>：如果订单数据的变更不频繁，可以考虑定期（如每天或每小时）计算并存储订单类型的金额总和，这样就不需要实时计算，而是直接查询预先计算好的结果。</li>
</ol>
<p>记住，在实际应用中，最佳的做法通常取决于具体的数据量、查询频率、硬件资源以及业务需求。因此，在实施任何优化策略之前，最好先进行性能测试和分析，以确定最有效的方案。</p>
<h3 id="应用层实现"><a href="#应用层实现" class="headerlink" title="应用层实现"></a>应用层实现</h3><p>在应用层使用多线程优化数据检索和计算操作，通常涉及将任务划分为多个子任务，并并行执行这些子任务以加快整体处理速度。对于数据库查询和计算订单类型金额总和的场景，可以通过以下步骤实现多线程优化：</p>
<ol>
<li><p><strong>任务分解</strong>：</p>
<ul>
<li>首先，确定哪些部分的任务可以并行执行。在数据库查询的场景中，如果查询的数据量非常大，并且数据库服务器能够支持并发查询，那么可以将查询拆分成多个子查询，每个子查询负责检索一部分数据。</li>
<li>对于计算订单类型金额总和的任务，如果每种订单类型的计算是独立的，那么也可以将这些计算任务分配给不同的线程并行执行。</li>
</ul>
</li>
<li><p><strong>创建线程或线程池</strong>：</p>
<ul>
<li>根据需要创建足够数量的线程或线程池来执行子任务。使用线程池可以避免频繁地创建和销毁线程，从而提高性能。</li>
<li>在Java中，可以使用<code>ExecutorService</code>和<code>ThreadPoolExecutor</code>来创建和管理线程池。</li>
</ul>
</li>
<li><p><strong>分配任务</strong>：</p>
<ul>
<li>将子任务分配给线程池中的线程执行。这通常涉及到将查询条件或计算参数传递给线程。</li>
</ul>
</li>
<li><p><strong>执行数据库查询</strong>：</p>
<ul>
<li>如果查询任务被拆分成多个子查询，每个线程将执行其分配的子查询，并获取结果集。</li>
<li>确保数据库连接是线程安全的，或者为每个线程创建独立的数据库连接。</li>
</ul>
</li>
<li><p><strong>计算金额总和</strong>：</p>
<ul>
<li>对于计算订单类型金额总和的任务，每个线程将处理其分配的订单类型，并计算相应的金额总和。</li>
<li>可以使用线程安全的集合（如<code>ConcurrentHashMap</code>）来存储每个订单类型的计算结果，以便后续合并。</li>
</ul>
</li>
<li><p><strong>合并结果</strong>：</p>
<ul>
<li>当所有线程完成其任务后，需要合并它们的结果。对于数据库查询，这通常意味着将各个子查询的结果集合并成一个完整的结果集。</li>
<li>对于金额总和的计算，需要将各个线程计算的结果相加，得到每种订单类型的总金额。</li>
</ul>
</li>
<li><p><strong>关闭线程池</strong>：</p>
<ul>
<li>一旦所有任务完成并且结果已经合并，关闭线程池以释放资源。</li>
</ul>
</li>
</ol>
<p>以下是一个简化的Java代码示例，展示了如何使用线程池并行执行数据库查询任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个DatabaseClient类用于执行数据库查询</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Order&gt; <span class="title function_">queryOrdersByTimeRange</span><span class="params">(Date startTime, Date endTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行数据库查询并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ...; <span class="comment">// 返回订单列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Order类代表订单，包含订单类型和金额等字段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    String orderType;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="comment">// ... 其他字段和构造函数等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadedExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        <span class="type">DatabaseClient</span> <span class="variable">databaseClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseClient</span>();</span><br><span class="line">        List&lt;Future&lt;List&lt;Order&gt;&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设我们按时间范围拆分查询任务</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">startTime</span> <span class="operator">=</span> ...; <span class="comment">// 昨天的开始时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">endTime</span> <span class="operator">=</span> ...;   <span class="comment">// 昨天的结束时间（或今天的开始时间）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">taskCount</span> <span class="operator">=</span> <span class="number">4</span>;    <span class="comment">// 假设我们将查询拆分成4个任务</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> (endTime.getTime() - startTime.getTime()) / taskCount;</span><br><span class="line">		<span class="comment">//！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">        <span class="comment">// 好好学学别人如何多线程处理带返回值的任务！❀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">taskStartTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(startTime.getTime() + i * interval);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">taskEndTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(Math.min(startTime.getTime() + (i + <span class="number">1</span>) * interval, endTime.getTime()));</span><br><span class="line">            Future&lt;List&lt;Order&gt;&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> databaseClient.queryOrdersByTimeRange(taskStartTime, taskEndTime);</span><br><span class="line">            &#125;);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成并合并结果</span></span><br><span class="line">        List&lt;Order&gt; allOrders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Order&gt;&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                allOrders.addAll(future.get()); <span class="comment">// 获取每个任务的结果并添加到总列表中，addAll()方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在可以对allOrders进行处理，比如计算每种订单类型的金额总和等</span></span><br><span class="line">         <span class="comment">// 处理allOrders，计算每种订单类型的金额总和  </span></span><br><span class="line">        Map&lt;String, Double&gt; totalAmountByOrderType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (Order order : allOrders) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> order.getOrderType();  </span><br><span class="line">            <span class="type">double</span> <span class="variable">amount</span> <span class="operator">=</span> order.getAmount();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 如果订单类型已经存在于map中，则累加金额；否则，初始化金额为当前订单的金额 ❀</span></span><br><span class="line">            <span class="comment">//！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">            <span class="comment">//这一步getOrDefault()方法恰到好处，查询是否存在键，存在返回值，不存在初始化值为0</span></span><br><span class="line">            totalAmountByOrderType.put(orderType, totalAmountByOrderType.getOrDefault(orderType, <span class="number">0.0</span>) + amount);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 打印每种订单类型的金额总和：MAP的遍历方法！❀</span></span><br><span class="line">        <span class="comment">// ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : totalAmountByOrderType.entrySet()) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Order Type: &quot;</span> + entry.getKey() + <span class="string">&quot;, Total Amount: &quot;</span> + entry.getValue());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引查询-❀"><a href="#索引查询-❀" class="headerlink" title="索引查询 ❀"></a>索引查询 ❀</h2><p>当你说“根据自己创建索引查询”，我理解为你想了解如何根据自己的需求在数据库中创建索引，并如何使用这些索引进行查询。以下是一个简单的例子，说明如何在关系型数据库中（以MySQL为例）创建索引并使用它进行查询。</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>假设我们有一个名为<code>users</code>的表，其中包含<code>id</code>、<code>name</code>和<code>email</code>三个字段。如果我们经常根据<code>email</code>字段进行查询，那么为了提高查询效率，我们可以为<code>email</code>字段创建一个索引。</p>
<ol>
<li><strong>使用<code>CREATE INDEX</code>语句创建索引</strong>：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_email <span class="keyword">ON</span> users(email);</span><br></pre></td></tr></table></figure>
<p>这条命令会在<code>users</code>表的<code>email</code>字段上创建一个名为<code>idx_email</code>的索引。</p>
<h3 id="使用索引进行查询"><a href="#使用索引进行查询" class="headerlink" title="使用索引进行查询"></a>使用索引进行查询</h3><p>一旦索引创建成功，你就可以在查询中使用它来提高性能。例如，如果你想根据<code>email</code>字段查找用户，你可以这样写查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;example@example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>MySQL优化器会自动决定是否使用<code>idx_email</code>索引来加速这个查询。如果它认为使用索引比全表扫描更快，它就会使用索引。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>选择性</strong>：索引的选择性越高，其效果通常越好。选择性是指不重复的索引值与总记录数的比率。例如，一个只有<code>true</code>和<code>false</code>两个值的字段可能不是一个好的索引候选，因为它的选择性很低。</li>
<li><strong>维护成本</strong>：每次插入、更新或删除记录时，索引都需要被更新。因此，过多的索引会增加写操作的开销。</li>
<li><strong>覆盖索引</strong>：如果一个查询只需要访问索引中的信息，而不需要回表访问数据行，那么这个查询就被称为“覆盖索引”查询。这种查询通常非常快。</li>
<li><strong>避免过度索引</strong>：只为那些经常出现在<code>WHERE</code>子句、<code>JOIN</code>条件或<code>ORDER BY</code>子句中的列创建索引。</li>
</ul>
<blockquote>
<p><strong>覆盖索引</strong>：</p>
<p><strong>索引就是你需要查询的列话，就不需要在磁盘加载其他数据块了，直接在索引库找到数据返回，减少IO次数，效率非常高！</strong></p>
<p>是指一个索引包含了查询所需的所有列，而无需访问表的实际数据页。当数据库系统执行查询时，通常需要从磁盘中读取数据页到内存中才能进行处理。而如果使用了覆盖索引，由于索引已经包含了查询所需的所有列的值，数据库系统可以直接通过索引来获取这些值，而不需要额外地读取数据页。这样可以减少磁盘I&#x2F;O的次数和数据在内存中的占用，提高查询的效率。</p>
</blockquote>
<p>最后，为了确定你的索引是否有效地提高了查询性能，你可以使用数据库的查询执行计划工具（如MySQL的<code>EXPLAIN</code>语句）来查看查询是如何使用索引的。</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><blockquote>
<p>当数据库表中同时建立id索引和name二级索引，数据库索引库会发生什么变化：</p>
<p>当然是对name字段生成一个索引库，如果说叶子节点包含完整的用户记录，索引库多了，将会占用磁盘很大空间，那我们该怎么办呢？</p>
<p>联想一下：id本身建立了索引并叶子节点携带所有数据，查询id是不是非常快，那么是不思路豁然开朗了！我们就可以选择重新建立name索引库，这次索引库叶子节点只包含name和id，数据量大大降低，根据name所查到的id，再去id索引库查询最终数据，因为name并不是一个主键索引，所以可能会有多个name对应结果，这样就需要<strong>回表</strong>，知道查询到对应的id数据为止！</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240323220646465.png" alt="image-20240323220646465"></p>
<blockquote>
<p>所以谈论这么多，联合索引又是什么呢？</p>
<p>相当于同时创建的两个二级索引，但是这个二级索引遵循<strong>最左原则</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_customer_order_date ON orders(name, phone);</span><br></pre></td></tr></table></figure>

<p>同样的是根据两个索引加上主键索引id创建索引库，即叶子节点不携带数据，这样的话会首先根据左边的name索引先排序，所以在叶子节点中会<strong>出现相同的节点，这时才会根据phone排序</strong>；所以说相同值的name节点下可能会保存不同的phone；<strong>所以如果直接搜索phone索引是乱序的就不会起作用</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240323221525110.png" alt="image-20240323221525110"></p>
<h2 id="MySQL-执行流程是怎样的？"><a href="#MySQL-执行流程是怎样的？" class="headerlink" title="MySQL 执行流程是怎样的？"></a>MySQL 执行流程是怎样的？</h2><p>先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li>
</ul>
<h3 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="line"># -u 指定用户名，管理员角色名为 root；</span><br><span class="line"># -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br><span class="line">mysql -h$ip -u$user -p</span><br><span class="line"># 查看连接最大连接时间</span><br><span class="line">show variables like &#x27;wait_timeout&#x27;;</span><br><span class="line"># 查看当前连接列表</span><br><span class="line">show processlist</span><br><span class="line">kill connection +id;</span><br><span class="line"># 支持最大连接数</span><br><span class="line">show variables like &#x27;max_connections&#x27;;</span><br></pre></td></tr></table></figure>

<p>连接器的工作做完了，简单总结一下：</p>
<ul>
<li>与客户端进行 TCP 三次握手建立连接；</li>
<li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li>
<li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li>
</ul>
<h3 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h3><blockquote>
<p>查询缓存如果查到了直接返回，但是事实上很鸡肋，缓存在数据库表更新的时候会被删除，以保证一致性，所以查询命中概率不高，所在在mysql8.0之后就抛弃了缓存这个概念！</p>
</blockquote>
<p>连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p>
<p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p>
<p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p>
<p>这么看，查询缓存还挺有用，但是其实<strong>查询缓存挺鸡肋</strong>的。</p>
<p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p>
<p>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p>
<p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND</p>
<h3 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h3><p>解析器会做如下两件事情。</p>
<p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>非关键字</th>
<th>关键字</th>
<th>非关键字</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>username</td>
<td>from</td>
<td>userinfo</td>
</tr>
</tbody></table>
<p>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/db-mysql-sql-parser-2.png" alt="img"></p>
<h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p>
<ul>
<li>prepare 阶段，也就是预处理阶段；</li>
<li>optimize 阶段，也就是优化阶段；</li>
<li>execute 阶段，也就是执行阶段；</li>
</ul>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><blockquote>
<p>查询表是否存在！</p>
</blockquote>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select id from tb_user where id &gt; 0 and nick_name = &quot;小鱼同学&quot;;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240323165903873.png" alt="image-20240323165903873"></p>
<blockquote>
<p>优化器会在多种索引中使用效率最高的索引 !</p>
</blockquote>
<p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><blockquote>
<p>InnoDB作为存储引擎会调用read_record 方法来根据不同策略来搜素：</p>
<ol>
<li>当搜索条件包含主键索引时，read_record(const,id)方法逐步查询</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(state!=-<span class="number">1</span>)&#123;</span><br><span class="line">    state = read_record(const,id);</span><br><span class="line">&#125;</span><br><span class="line">Integet <span class="title function_">read_record</span><span class="params">(Enum <span class="keyword">enum</span>,Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录</span></span><br><span class="line">    <span class="keyword">if</span>(isResultTrue(id))&#123;</span><br><span class="line">        <span class="comment">//将数据返回给客户端</span></span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当不包含索引时，read_record(all)方法循环查询，查询到匹配的将一个一个返回到客户端</li>
</ol>
</blockquote>
<p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p>
<p>执行器和存储引擎的交互过程：</p>
<ul>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推</li>
</ul>
<h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><p>以本文开头查询语句为例，看看执行器是怎么工作的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li>
<li>存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li>
<li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li>
</ul>
<p>至此，这个语句就执行完成了。</p>
<h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>举个全表扫描的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product where name = &#x27;iphone&#x27;;</span><br></pre></td></tr></table></figure>

<p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li>
<li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li>
<li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li>
<li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li>
</ul>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在这部分非常适合讲<strong>索引下推（MySQL 5.6 推出的查询优化策略）</strong>，这样大家能清楚的知道，「下推」这个动作，下推到了哪里。</p>
<p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p>
<p>举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%B7%AF%E9%A3%9E%E8%A1%A8.png" alt="img"></p>
<p>现在有下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。具体原因这里可以看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">索引常见面试题(opens new window)</a></p>
<p>那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li>
<li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li>
<li>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</li>
<li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</li>
<li>如此往复，直到存储引擎把表中的所有记录读完。</li>
</ul>
<p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p>
<p>而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p>
<ul>
<li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li>
<li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li>
<li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li>
<li>如此往复，直到存储引擎把表中的所有记录读完。</li>
</ul>
<blockquote>
<p><strong>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward &#x3D; 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</strong></p>
</blockquote>
<p>当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h2 id="SQL知识加油站"><a href="#SQL知识加油站" class="headerlink" title="SQL知识加油站"></a>SQL知识加油站</h2><h3 id="关联查询-inner-join"><a href="#关联查询-inner-join" class="headerlink" title="关联查询 - inner join"></a>关联查询 - inner join</h3><p>在 SQL 中，INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。</p>
<p>注意，INNER JOIN 只返回两个表中<strong>满足关联条件的交集部分</strong>，即在两个表中都存在的匹配行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  s.name student_name,</span><br><span class="line">  s.age student_age,</span><br><span class="line">  s.class_id class_id,</span><br><span class="line">  c.name class_name,</span><br><span class="line">  c.level class_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student s</span><br><span class="line">  <span class="keyword">join</span> class c <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240327151951963.png" alt="image-20240327151951963"></p>
<h3 id="关联查询-cross-join"><a href="#关联查询-cross-join" class="headerlink" title="关联查询 - cross join"></a>关联查询 - cross join</h3><p>在 SQL 中，关联查询是一种用于联合多个数据表中的数据的查询方式。</p>
<p>其中，<code>CROSS JOIN</code> 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 <strong>每一行</strong> 与右表的 <strong>每一行</strong> 进行组合，返回的结果是两个表的笛卡尔积。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name student_name,s.age student_age,s.class_id, c.name class_name</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">JOIN</span> class c;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240327152915920.png" alt="image-20240327152915920"></p>
<h3 id="关联查询-outer-join"><a href="#关联查询-outer-join" class="headerlink" title="关联查询 - outer join"></a>关联查询 - outer join</h3><p>在 SQL 中，OUTER JOIN 是一种关联查询方式，它根据指定的关联条件，将两个表中满足条件的行组合在一起，并 <strong>包含没有匹配的行</strong> </p>
<p>在 OUTER JOIN 中，包括 <strong>LEFT OUTER JOIN 和 RIGHT OUTER JOIN</strong> 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name student_name,s.age student_age,s.class_id,c.name class_name,c.level class_level</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">JOIN</span>  class c <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../image/image-20240327162843180.png" alt="image-20240327162843180"></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">FANSEA</div><div class="post-copyright__author_desc">目标明确，只管去做</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/03/23/MySQL/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/03/23/MySQL/')">MySQL深入浅出</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/03/23/MySQL/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=MySQL深入浅出&amp;url=http://example.com/2024/03/23/MySQL/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">FANSEA</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/mysql/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>mysql<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/fansea.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/20/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%9D%E6%83%B3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高并发思想</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/27/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%81/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">每日学习计划！</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fansea.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">MySQL深入浅出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E9%97%AE"><span class="toc-number">1.1.</span> <span class="toc-text">开篇第一问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">设计索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%98%A8%E5%A4%A9%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">打印昨天的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%AE%A2%E5%8D%95%E7%B1%BB%E5%9E%8B%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D%E6%80%BB%E5%92%8C"><span class="toc-number">1.1.3.</span> <span class="toc-text">根据订单类型计算金额总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">使用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D%E6%80%BB%E5%92%8C"><span class="toc-number">1.1.5.</span> <span class="toc-text">追问：怎么计算金额总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">应用层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2-%E2%9D%80"><span class="toc-number">1.2.</span> <span class="toc-text">索引查询 ❀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用索引进行查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">MySQL 执行流程是怎样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">第一步：连接器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">第二步：查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%A7%A3%E6%9E%90-SQL"><span class="toc-number">1.4.3.</span> <span class="toc-text">第三步：解析 SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E6%89%A7%E8%A1%8C-SQL"><span class="toc-number">1.5.</span> <span class="toc-text">第四步：执行 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">预处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">优化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">执行器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">主键索引查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">全表扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">索引下推</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E7%9F%A5%E8%AF%86%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">1.6.</span> <span class="toc-text">SQL知识加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2-inner-join"><span class="toc-number">1.6.1.</span> <span class="toc-text">关联查询 - inner join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2-cross-join"><span class="toc-number">1.6.2.</span> <span class="toc-text">关联查询 - cross join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2-outer-join"><span class="toc-number">1.6.3.</span> <span class="toc-text">关联查询 - outer join</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/01/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E4%BE%9D%E8%B5%96/" title="项目构建依赖">项目构建依赖</a><time datetime="2024-04-01T13:09:53.000Z" title="发表于 2024-04-01 21:09:53">2024-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/27/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%81/" title="每日学习计划！">每日学习计划！</a><time datetime="2024-03-27T13:25:46.000Z" title="发表于 2024-03-27 21:25:46">2024-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/23/MySQL/" title="MySQL深入浅出">MySQL深入浅出</a><time datetime="2024-03-23T07:42:06.000Z" title="发表于 2024-03-23 15:42:06">2024-03-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/20/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%9D%E6%83%B3/" title="高并发思想">高并发思想</a><time datetime="2024-03-20T07:41:37.000Z" title="发表于 2024-03-20 15:41:37">2024-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/20/%E5%95%86%E6%9C%BA%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%80%EF%BC%89/" title="商机思考（一）">商机思考（一）</a><time datetime="2024-03-20T04:09:15.000Z" title="发表于 2024-03-20 12:09:15">2024-03-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="FANSEA" target="_blank">FANSEA</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Redis/" style="font-size: 0.88rem;">Redis<sup>3</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/es/" style="font-size: 0.88rem;">es<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>1</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/%E4%BE%9D%E8%B5%96%E5%8C%85/" style="font-size: 0.88rem;">依赖包<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 0.88rem;">内网穿透<sup>1</sup></a><a href="/tags/%E5%95%86%E4%B8%9A%E6%80%9D%E8%80%83/" style="font-size: 0.88rem;">商业思考<sup>2</sup></a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 0.88rem;">微服务<sup>1</sup></a><a href="/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/" style="font-size: 0.88rem;">技能提升<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E8%AE%B0/" style="font-size: 0.88rem;">日记<sup>1</sup></a><a href="/tags/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" style="font-size: 0.88rem;">登录校验<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>5</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">编程工具<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 0.88rem;">读书<sup>2</sup></a><a href="/tags/%E8%B1%AA%E8%BD%A6/" style="font-size: 0.88rem;">豪车<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>4</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>1</sup></a><a href="/tags/%EF%BC%9BMySQL/" style="font-size: 0.88rem;">；MySQL<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 FANSEA 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>